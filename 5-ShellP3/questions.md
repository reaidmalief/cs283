1. Your shell forks multiple child processes when executing piped commands. How does your implementation ensure that all child processes complete before the shell continues accepting user input? What would happen if you forgot to call waitpid() on all child processes?

 > **Answer**: In my implementation, after forking child processes to execute each command in the pipeline, I loop through the array of child PIDs and use `waitpid()` to wait for each one to finish before the shell returns to the prompt. This ensures that all commands in the pipeline have completed their execution, preventing interleaved outputs or resource conflicts. If I were to omit the calls to `waitpid()`, the shell could continue accepting user input while some child processes are still running. This would lead to orphaned or zombie processes, and their outputs might unexpectedly mix with new prompt displays, making the shell’s behavior unreliable.

2. The dup2() function is used to redirect input and output file descriptors. Explain why it is necessary to close unused pipe ends after calling dup2(). What could go wrong if you leave pipes open?

 > **Answer**: After redirecting file descriptors using `dup2()`, it’s crucial to close the unused pipe ends. This is because `dup2()` duplicates the file descriptor, but the original file descriptors remain open if not explicitly closed. Leaving them open can cause several issues: it may lead to resource leaks, and more importantly, a process reading from a pipe might never see an end-of-file (EOF) if the write end is still open elsewhere. This could result in the process hanging indefinitely, waiting for input that will never come.

3. Your shell recognizes built-in commands (cd, exit, dragon). Unlike external commands, built-in commands do not require execvp(). Why is cd implemented as a built-in rather than an external command? What challenges would arise if cd were implemented as an external process?

 > **Answer**: I implemented `cd` as a built-in command because it needs to modify the shell's own working directory. If `cd` were executed as an external command in a separate child process, any changes to the directory would only affect that child, leaving the parent shell's working directory unchanged. This would render the `cd` command ineffective for the user. Handling `cd` internally allows the shell to update its environment, ensuring that the directory change persists for all subsequent commands.

4. Currently, your shell supports a fixed number of piped commands (CMD_MAX). How would you modify your implementation to allow an arbitrary number of piped commands while still handling memory allocation efficiently? What trade-offs would you need to consider?

 > **Answer**: To support an arbitrary number of piped commands, I would replace the fixed-size array with a dynamic data structure, such as a dynamically allocated array or linked list, which could grow as needed. I would use `malloc()` and `realloc()` to manage memory efficiently based on the actual number of commands entered by the user. The trade-offs include increased code complexity and potential performance overhead due to dynamic memory management, but this approach provides the flexibility to handle any number of piped commands while still controlling memory usage effectively. 
